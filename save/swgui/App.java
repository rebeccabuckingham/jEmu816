/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jEmu816.swgui;

import com.formdev.flatlaf.FlatDarkLaf;
import com.formdev.flatlaf.FlatLightLaf;
import com.formdev.flatlaf.themes.FlatMacDarkLaf;
import com.formdev.flatlaf.themes.FlatMacLightLaf;
import jEmu816.Acia;
import jEmu816.Crtc;
import jEmu816.Keyboard;
import jEmu816.Machine;
import jEmu816.Util;
import jEmu816.ui.VideoWindow;
import jEmu816.cpu.Cpu;
import jEmu816.ui.Console;
import jEmu816.ui.FifoUnderrunException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class App implements GuiController, WDMHandler {
	private static final Logger logger = LoggerFactory.getLogger(App.class);
	private static final String ONE_MHZ = "1 Mhz";
	private static final String TWO_MHZ = "2 Mhz";
	private static final String FOUR_MHZ = "4 Mhz";
	private static final String EIGHT_MHZ = "8 Mhz";

	public static final Map<String, Integer> freqToNanosMap =
		Map.of(ONE_MHZ, 1000, TWO_MHZ, 500,
					 FOUR_MHZ, 250, EIGHT_MHZ, 125);

	MainView gui;
	Machine machine;
	Cpu cpu;
	Console console;
	Crtc crtc;
	Acia acia;
	VideoWindow videoWindow;
	RunLoop runLoop;
	boolean runLoopIsInvalid = false;

	// move these and add initializing code
	boolean breakpointsEnabled = false;
	ArrayList<Object[]> breakpointsList = new ArrayList<>();
	List<String> machineList = List.of("TestMachine", "CrtcMachine", "Sentinel", "RefMachine");
	String speedKey = TWO_MHZ;

	public void createAndShowGui() {
		logger.debug("createAndShowGui()");

		// set some defaults before bringing up gui...
		//updateSpeed(TWO_MHZ);
		//updateMachine(machineList.get(0));

		gui = new MainView(this);
		console = gui.console;

		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				logger.debug("setting cpu on registers panel");
				//gui.registerPanel.setCpu(machine.bus.getCpu());
				//gui.registerPanel.updateRegistersFromCpu();
				gui.centerOnScreen();
				gui.setVisible(true);
			}
		});
	}

	public void loadFile(String filename) {
		try {
			int loadAddress = Util.loadFile(machine, filename);
			if (filename.endsWith(".prg") || filename.endsWith(".PRG")) {
				machine.getBus().getCpu().pbr = 0;
				machine.getBus().getCpu().pc = loadAddress;
				gui.registerPanel.updateRegistersFromCpu();
			}
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null, "Could not load file: " + e.getMessage());
		}
	}

	public void runStopButtonClicked() {
		if (runLoop != null && !runLoopIsInvalid) {
			if (runLoop.isrunning)
				runLoop.requestStop();
			else {
				runLoop.start();
			}
		} else {
			// apparently, we need a new RunLoop.
			runLoop = new RunLoop(machine);
			runLoop.start();
		}
	}

	public void resetButtonClicked() {
		if (machine != null) {
			if (runLoop != null && runLoop.isrunning) {
				runLoop.requestStop();
				java.awt.EventQueue.invokeLater(() -> {
					if (runLoop.isrunning) {
						try {
							Thread.sleep(100);
						} catch (InterruptedException e) {
							throw new RuntimeException(e);
						}
					}
					machine.reset();
					gui.registerPanel.updateRegistersFromCpu();
				});
			} else {
				machine.reset();
				gui.registerPanel.updateRegistersFromCpu();
			}
		}
	}

	public void stepButtonClicked() {
		if (runLoop != null && !runLoop.isRunning()) {
			runLoop.singleStep();
			System.out.println(cpu.toString());
		}
	}

	@SuppressWarnings("unchecked")
	public void updateMachine(String machineClassName) {
		logger.debug("updateMachine('" + machineClassName + "')");
		try {
			Class<Machine> machineClass =
				(Class<Machine>) Class.forName("jEmu816.machines." + machineClassName);

			var constructors = machineClass.getConstructors();
			machine = (Machine) constructors[0].newInstance();
			machine.setWDMHandler(this);
			cpu = machine.bus.getCpu();
			cpu.stopped = true;
			updateSpeed(speedKey);

			if (machine.hasCrtc) {
				crtc = machine.getCrtc();
				videoWindow = new VideoWindow(machine.getCrtc(), 2, 2);
				videoWindow.setVisible(true);

				Keyboard keyboard = (Keyboard) machine.getBus().findDeviceByClass(Keyboard.class);
				if (keyboard != null) {
					videoWindow.setKeyboardDevice(keyboard);
				}
			} else {
				if (videoWindow != null)
					videoWindow.dispose();
				crtc = null;
			}

			if (machine.hasAcia()) {
				acia = machine.getAcia();
			} else {
				acia = null;
			}

			if (gui != null) {
				gui.registerPanel.setCpu(cpu);
				gui.registerPanel.updateRegistersFromCpu();
			}

			runLoop = new RunLoop(machine);
			logger.debug("updateMachine() successful.");
		} catch (Exception e) {
			logger.error("updateMachine() failed", e);
		}
	}

	@Override
	public void handleWDM(int sigByte) {
		if (runLoop != null && sigByte == 0xff) {
			runLoop.stopRequested = true;
		}
	}

	public void updateGuiFromRunLoop(boolean stopped) {
		// note: set runStopButton text based on 'stopped'.
		gui.registerPanel.updateRegistersFromCpu();
		if (stopped) {
			gui.setRunStopButtonText("Run");
		}
	}

	public void updateCrtcFromRunLoop() {
		if (videoWindow != null && videoWindow.isVisible()) {
			videoWindow.repaint();
		}
	}

	public void updateConsoleFromRunLoop() {
		// read from the acia and update the console
		// hasTxChar = *this* computer has sent a char to the terminal (console).
		if (acia != null && acia.hasTxChar()) {
			console.print(Character.toString((char) acia.txRead(true)));
			console.repaint();
		}

		// if a key has been pressed, fill the acia.
		// rxWrite = send from the remote terminal (console) to this computer.
		try {
			if (acia != null && console.hasInput()) {
				acia.rxWrite((int) console.readInputChar());
			}
		} catch (FifoUnderrunException ex) {
			logger.error("console type-ahead buffer underrun happened.");
		}
	}

	public String getSpeed() {
		return speedKey;
	}

	public String getMachineKey() {
		return machine.getName();
	}

	public void setBreakpointsList(ArrayList<Object[]> list) {
		this.breakpointsList = list;
		logger.info("setBreakpointsList: " + list.toString());
	}

	public ArrayList<Object[]> getBreakpointsList() {
		return breakpointsList;
	}

	public void updateSpeed(String speedKey) {
		this.speedKey = speedKey;

		if (machine != null) {
			int nanosPerCycle = freqToNanosMap.get(speedKey);
			machine.getBus().getCpu().setNanosPerCycle(nanosPerCycle);

			if (machine.hasVera()) {
				int mhz = (int) ((1D / nanosPerCycle) * 1000);
				machine.getVera().videoInit(2, 1, mhz);
			}

		}
	}

	public boolean getBreakpointsEnabled() {
		return this.breakpointsEnabled;
	}

	public void setBreakpointsEnabled(boolean value) {
		this.breakpointsEnabled = value;
		logger.debug("breakpointsEnabled: " + value);
	}

	public List<String> getMachineList() {
		return machineList;
	}

	public List<String> getClockSpeedList() {
		ArrayList<String> list = new ArrayList<>();
		freqToNanosMap.keySet().stream().sorted().forEach(list::add);
		return list;
	}

	private class RunLoop extends Thread {
		private static final int nsecBetweenUpdates = 100000;
		private static final int nsecBetweenCrtcUpdates = 100000;
		private static final int nsecBetweenConsoleUpdates = 100000;

		private Machine machine = null;
		private Cpu cpu = null;

		private boolean stopRequested = false;
		private boolean isrunning = false;

		private ArrayList<Object[]> breakpointsList;

		boolean haveCrtc = false;
		boolean haveConsole = false;

		public RunLoop(Machine machine) {
			this.machine = machine;
			this.cpu = machine.bus.getCpu();
			haveCrtc = machine.hasCrtc;
			haveConsole = machine.hasAcia() && machine.hasConsole;
			if (gui != null) {
				gui.logTextArea.setText("tracelog ready...");
			}
		}

		public boolean isRunning() {
			return isrunning;
		}

		@Override
		public synchronized void start() {
			super.start();
		}

		public void singleStep() {
			step();
			gui.logTextArea.append(cpu.toString() + "\n");
			updateGuiFromRunLoop(true);
			updateCrtcFromRunLoop();
			updateConsoleFromRunLoop();
		}

		private boolean checkbreakPoints() {
			boolean breakpointHit = false;
			for (Object[] item : breakpointsList) {
				if ((Boolean) item[0]) {
					var bpAddress = (String) item[1];
					// $00:0000
					// 01234567
					int _pbr = Integer.parseInt(bpAddress.substring(1, 3), 16);
					int _pc = Integer.parseInt(bpAddress.substring(4, 8), 16);
					if (_pbr == cpu.pbr && _pc == cpu.pc) {
						breakpointHit = true;
						break;
					}
				}
			}
			return breakpointHit;
		}

		@Override
		public void run() {
			stopRequested = false;
			isrunning = true;

			gui.setRunStopButtonText("Stop");

			// console takes priority over CRTC video
			if (haveCrtc) {
				videoWindow.requestFocus();
			}

			if (haveConsole) {
				console.requestFocus();
			}

			updateGuiFromRunLoop(false);

			long lastUpdateNSec = 0;
			long lastCrtcUpdateNSec = 0;
			long lastConsoleUpdateNSec = 0;

			while (!stopRequested) {
				step();

				// do updates based on run time
				long now = System.nanoTime();

				if (now - lastUpdateNSec >= nsecBetweenUpdates) {
					updateGuiFromRunLoop(false);
					lastUpdateNSec = now;
				}

				if (haveCrtc && (now - lastCrtcUpdateNSec >= nsecBetweenCrtcUpdates)) {
					updateCrtcFromRunLoop();
					lastCrtcUpdateNSec = now;
				}

				if (haveConsole && (now - lastConsoleUpdateNSec >= nsecBetweenConsoleUpdates)) {
					updateConsoleFromRunLoop();
					lastConsoleUpdateNSec = now;
				}

				// process breakpoints list
				if (breakpointsEnabled) {
					if (checkbreakPoints()) {
						logger.info("breakpoint hit!");
						logger.info(cpu.toString());
						stopRequested = true;
					}
				}
			}

			isrunning = false;
			stopRequested = false;
			updateGuiFromRunLoop(true);
			runLoopIsInvalid = true;
		}

		private void step() {
			cpu.step();
		}

		public void requestStop() {
			stopRequested = true;
		}
	}

	public static void main(String[] args) throws Exception {
		String osName = System.getProperty("os.name");
		String lafName;

		if (osName.equalsIgnoreCase("mac os x")) {
			FlatMacLightLaf.setup();
			FlatMacDarkLaf.setup();
			lafName = FlatMacLightLaf.class.getName();
		} else {
			FlatLightLaf.setup();
			FlatDarkLaf.setup();
			lafName = FlatLightLaf.class.getName();
		}

		FlatMacLightLaf.setup();
		javax.swing.UIManager.setLookAndFeel(lafName);

		App app = new App();
		app.createAndShowGui();

		String machineType;
		String filename;
		String runAddress = "";

		if (args.length >= 2) {
			machineType = args[0];
			filename = args[1];
			if (args.length == 3) {
				runAddress = args[2];
			}

			app.updateMachine(machineType);
			app.loadFile(filename);

			if (! filename.toLowerCase().endsWith(".prg")
				&& !runAddress.isBlank()) {
				int iRunAddress = Integer.parseInt(runAddress, 16);

				int pbr = iRunAddress >> 16;
				int pc = iRunAddress & 0xffff;

				app.machine.getBus().getCpu().pbr = pbr;
				app.machine.getBus().getCpu().pc = pc;
			}

			app.runStopButtonClicked();
		}
	}

}
